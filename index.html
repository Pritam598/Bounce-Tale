<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Bounce Tales: Boss Battle</title>
    <style>
        @font-face { font-family: 'PixelFont'; src: local('Courier New'), local('Courier'), monospace; }
        
        body {
            background-color: #202020; margin: 0; padding: 0;
            display: flex; justify-content: center; align-items: center;
            height: 100vh; overflow: hidden;
            font-family: 'PixelFont', monospace; touch-action: none; user-select: none;
        }

        #game-device {
            position: relative; width: 100%; max-width: 740px; aspect-ratio: 16/9;
            background: #000; border: 6px solid #444; border-radius: 20px;
            box-shadow: 0 20px 50px rgba(0,0,0,0.8); overflow: hidden;
        }

        canvas { display: block; width: 100%; height: 100%; image-rendering: pixelated; }

        #ui {
            position: absolute; top: 15px; left: 20px; right: 20px;
            display: flex; justify-content: space-between;
            color: #fff; font-size: 16px; font-weight: bold;
            text-shadow: 2px 2px 0 #000; pointer-events: none; z-index: 20;
        }
        
        .hud-box {
            background: rgba(0,0,0,0.6); padding: 8px 15px;
            border-radius: 20px; border: 2px solid rgba(255,255,255,0.8);
            box-shadow: 0 4px 0 rgba(0,0,0,0.4);
        }

        #overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85);
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            color: white; z-index: 30; backdrop-filter: blur(5px);
        }
        
        h1 { font-size: 48px; color: #ffeb3b; text-shadow: 4px 4px 0 #ff5722; margin: 0 0 15px 0; letter-spacing: 2px; text-align: center; }
        p { margin-bottom: 25px; color: #eee; text-align: center; font-size: 16px; line-height: 1.6; }

        button {
            background: #00e676; border: 3px solid #fff;
            padding: 15px 40px; font-family: inherit; font-size: 20px;
            font-weight: bold; color: #004d40; cursor: pointer;
            box-shadow: 0 6px 0 #00a152; border-radius: 30px; transition: all 0.1s;
        }
        button:active { transform: translateY(6px); box-shadow: none; }

        #mobile-controls {
            position: absolute; bottom: 10px; left: 0; width: 100%; height: 120px;
            display: none; pointer-events: none; z-index: 25;
        }
        
        .d-pad { position: absolute; bottom: 15px; left: 20px; width: 140px; height: 90px; pointer-events: auto; }
        
        .btn-round { 
            position: absolute; bottom: 20px; width: 70px; height: 70px; 
            border-radius: 50%; pointer-events: auto; 
            display:flex; justify-content:center; align-items:center;
            color:white; font-size:18px; font-weight:bold;
            box-shadow: 0 5px 0 rgba(0,0,0,0.5); transition: transform 0.1s;
        }

        #btn-jump { right: 20px; background: #2979ff; border: 3px solid #82b1ff; }
        #btn-jump:active { background: #1565c0; transform: translateY(5px); box-shadow: none; }
        #btn-shoot { right: 110px; background: #ff1744; border: 3px solid #ff8a80; font-size: 24px;}
        #btn-shoot:active { background: #d50000; transform: translateY(5px); box-shadow: none; }
        
        .arrow { 
            width: 60px; height: 60px; 
            background: #ffab00; border: 3px solid #ffe57f; 
            position: absolute; display: flex; justify-content: center; align-items: center; 
            font-size: 30px; color: #3e2723; user-select: none; border-radius: 15px;
            pointer-events: auto; box-shadow: 0 5px 0 #ef6c00;
        }
        .arrow:active { transform: translateY(5px); box-shadow: none; }
        .left { left: 0; bottom: 0; } .right { right: 0; bottom: 0; }

        @media (max-width: 800px) {
            #mobile-controls { display: block; }
            #game-device { width: 100vw; height: 100vh; max-width: none; border: none; border-radius: 0; }
        }
    </style>
</head>
<body>

<div id="game-device">
    <canvas id="gameCanvas" width="480" height="270"></canvas>
    
    <div id="ui">
        <div class="hud-box">⭐ COINS: <span id="scoreVal" style="color:#FFD700">0</span></div>
        <div class="hud-box" id="levelDisplay">LEVEL 1</div>
    </div>

    <div id="overlay">
        <h1 id="overlay-title">BOUNCE BOSS</h1>
        <p id="overlay-msg">
            Arrows to Move. Blue to Jump. Red to Shoot.<br>
            <b>LEVEL 3</b> has a BOSS FIGHT!<br>
            Defeat the <b>Dark King</b>!
        </p>
        <button id="overlay-btn" onclick="handleOverlayClick()">LET'S GO!</button>
    </div>

    <div id="mobile-controls">
        <div class="d-pad"><div class="arrow left" id="btn-left">‹</div><div class="arrow right" id="btn-right">›</div></div>
        <div class="btn-round" id="btn-shoot">●</div>
        <div class="btn-round" id="btn-jump">UP</div>
    </div>
</div>

<script>
/** BOUNCE TALES: BOSS EDITION */

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

// --- SOUND ENGINE ---
const Sound = {
    ctx: null,
    init: function() {
        if (!this.ctx) this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        else if (this.ctx.state === 'suspended') this.ctx.resume();
    },
    play: function(type) {
        if (!this.ctx) return;
        const t = this.ctx.currentTime;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.connect(gain); gain.connect(this.ctx.destination);

        if (type === 'jump') {
            osc.type = 'square'; osc.frequency.setValueAtTime(150, t); osc.frequency.exponentialRampToValueAtTime(600, t + 0.1);
            gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
            osc.start(t); osc.stop(t + 0.15);
        } else if (type === 'shoot') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(800, t); osc.frequency.exponentialRampToValueAtTime(100, t + 0.15);
            gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.15);
            osc.start(t); osc.stop(t + 0.15);
        } else if (type === 'boss_hit') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(100, t); osc.frequency.linearRampToValueAtTime(50, t + 0.1);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 0.1);
            osc.start(t); osc.stop(t + 0.1);
        } else if (type === 'boss_shoot') {
            osc.type = 'square'; osc.frequency.setValueAtTime(200, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.3);
            gain.gain.setValueAtTime(0.1, t); gain.gain.linearRampToValueAtTime(0, t + 0.3);
            osc.start(t); osc.stop(t + 0.3);
        } else if (type === 'coin') {
            osc.type = 'sine'; osc.frequency.setValueAtTime(1200, t); osc.frequency.setValueAtTime(1600, t + 0.05);
            gain.gain.setValueAtTime(0.1, t); gain.gain.exponentialRampToValueAtTime(0.01, t + 0.3);
            osc.start(t); osc.stop(t + 0.3);
        } else if (type === 'die') {
            osc.type = 'sawtooth'; osc.frequency.setValueAtTime(400, t); osc.frequency.exponentialRampToValueAtTime(50, t + 0.6);
            gain.gain.setValueAtTime(0.2, t); gain.gain.linearRampToValueAtTime(0, t + 0.6);
            osc.start(t); osc.stop(t + 0.6);
        }
    }
};

// --- ASSETS ---
function createTexture(w, h, drawFn) {
    const c = document.createElement('canvas'); c.width = w; c.height = h;
    const x = c.getContext('2d'); drawFn(x, w, h); return c;
}
const ballSprite = createTexture(32, 32, (c, w, h) => {
    let cx = w/2, cy = h/2, r = w/2 - 1;
    let g = c.createRadialGradient(cx-4, cy-4, 2, cx, cy, r); g.addColorStop(0, '#ff5e5e'); g.addColorStop(1, '#d50000');
    c.fillStyle = g; c.beginPath(); c.arc(cx, cy, r, 0, Math.PI*2); c.fill();
    c.fillStyle = 'white'; c.beginPath(); c.ellipse(cx-6, cy-4, 5, 7, 0, 0, Math.PI*2); c.fill(); c.beginPath(); c.ellipse(cx+6, cy-4, 5, 7, 0, 0, Math.PI*2); c.fill();
    c.fillStyle = 'black'; c.beginPath(); c.arc(cx-5, cy-4, 2, 0, Math.PI*2); c.fill(); c.beginPath(); c.arc(cx+5, cy-4, 2, 0, Math.PI*2); c.fill();
    c.strokeStyle = '#3e2723'; c.lineWidth = 2; c.beginPath(); c.arc(cx, cy+2, 6, 0.2, Math.PI-0.2); c.stroke();
});
const tileSprite = createTexture(20, 20, (c, w, h) => {
    c.fillStyle = '#795548'; c.fillRect(0, 0, w, h); c.fillStyle = '#76ff03'; c.fillRect(0, 0, w, 6);
    c.fillStyle = '#64dd17'; c.fillRect(0, 6, w, 2); c.fillStyle = '#a1887f'; c.fillRect(5, 12, 4, 4);
});
const bossSprite = createTexture(40, 40, (c, w, h) => {
    let cx = w/2, cy = h/2;
    c.fillStyle = '#4a148c'; c.beginPath(); c.arc(cx, cy, 18, 0, Math.PI*2); c.fill(); // Body
    c.fillStyle = '#ffeb3b'; c.beginPath(); c.moveTo(cx-10, cy-12); c.lineTo(cx, cy-22); c.lineTo(cx+10, cy-12); c.lineTo(cx+5, cy-8); c.lineTo(cx-5, cy-8); c.fill(); // Crown
    c.fillStyle = 'white'; c.beginPath(); c.arc(cx-6, cy, 5, 0, Math.PI*2); c.fill(); c.beginPath(); c.arc(cx+6, cy, 5, 0, Math.PI*2); c.fill(); // Eyes
    c.fillStyle = 'red'; c.beginPath(); c.arc(cx-6, cy, 2, 0, Math.PI*2); c.fill(); c.beginPath(); c.arc(cx+6, cy, 2, 0, Math.PI*2); c.fill();
    c.strokeStyle = 'white'; c.lineWidth = 2; c.beginPath(); c.moveTo(cx-8, cy-4); c.lineTo(cx, cy+2); c.stroke(); // Angry
});
const bounceSprite = createTexture(20, 20, (c, w, h) => {
    c.fillStyle = '#5d4037'; c.fillRect(0, 0, w, h); c.fillStyle = '#ff9800'; c.fillRect(2, 2, 16, 16);
    c.strokeStyle = '#e65100'; c.lineWidth = 2; c.strokeRect(2,2,16,16);
});
const waterSprite = createTexture(20, 20, (c, w, h) => {
    c.fillStyle = 'rgba(64, 196, 255, 0.7)'; c.fillRect(0, 0, w, h); c.fillStyle = 'rgba(255,255,255,0.4)'; c.fillRect(2, 4, 8, 2);
});
const enemySprite = createTexture(24, 24, (c, w, h) => {
    let cx = w/2, cy = h/2; c.fillStyle = '#ab47bc'; c.beginPath(); c.arc(cx, cy, 10, 0, Math.PI*2); c.fill();
    c.fillStyle = '#fff'; c.beginPath(); c.arc(cx-4, cy-2, 3, 0, Math.PI*2); c.fill(); c.beginPath(); c.arc(cx+4, cy-2, 3, 0, Math.PI*2); c.fill();
    c.fillStyle = '#000'; c.beginPath(); c.arc(cx-4, cy-2, 1, 0, Math.PI*2); c.fill(); c.beginPath(); c.arc(cx+4, cy-2, 1, 0, Math.PI*2); c.fill();
});
const flagSprite = createTexture(20, 40, (c, w, h) => {
    c.fillStyle = '#795548'; c.fillRect(2, 0, 4, 40); c.fillStyle = '#ffeb3b'; c.beginPath(); c.moveTo(6, 2); c.lineTo(20, 10); c.lineTo(6, 18); c.fill();
});
const flowerSprite = createTexture(20, 20, (c, w, h) => {
    c.fillStyle = '#4caf50'; c.fillRect(9, 10, 2, 10); c.fillStyle = '#f44336'; c.beginPath(); c.arc(10, 10, 4, 0, Math.PI*2); c.fill();
});

const TILE_SIZE = 20;
const JUMP_FORCE = -7.8; 
const BOUNCE_FORCE = -14;
const GRAVITY = 0.35; 
const ACCEL = 0.25; 
const FRICTION = 0.9;
const MAX_SPEED = 4.5;

let gameState = 'MENU';
let currentLevelIndex = 0;
let camera = { x: 0, y: 0 };
let score = 0;
let globalTime = 0;
let keys = { left: false, right: false, up: false };
let particles = [];
let bullets = [];
let enemyBullets = [];
let lastShootTime = 0;
let decor = [];

const levels = [
    [
        "............................................................................................................................................................................................................................................................................................................................................",
        "............................................................................................................................................................................................................................................................................................................................................",
        "............................................................................................................................................................................................................................................................................................................................................",
        "............................................................................................................................................................................................................................................................................................................................................",
        "..............................................................................3..3....................................3.3.3...........................................................................................................................................................................................................",
        "............................................................................#######..................................#######..........................................................................................................................................................................................................",
        "......................................3..................3..................#.....#.................................##.....##.........................................................................................................................................................................................................",
        ".....................................###...............#####................#.....#................................##.......##........................................................................................................................................................................................................",
        "........S..............E............#####.......V......#####.......3........#.....#........E..........3......V....##.........##...............9.......................................................................................................................................................................................",
        "......####............###..........#######............#####......###.......#.....#.......###........###..........#...........#..............###.......................................................................................................................................................................................",
        "#####...#####...#####...#####...###.......#####...#####.....######...#######.......#######...########...#####...##.............##...#########...############........................................................................................................................................................................",
        "............................................................................................................................................................................................................................................................................................................................................"
    ],
    [
        ".......................................................................................................................................................................................................................................................................................................",
        ".......................................................................................................................................................................................................................................................................................................",
        ".......................................................................................................................................................................................................................................................................................................",
        "...................................................................................................3...................................................................................................................................................................................................",
        "...................................................................3.............................#####.................................................................................................................................................................................................",
        ".................................................................#####...........................#...#....................................................3.3.3......................................................................................................................................",
        "..................................................3..............#...#...........V...............#...#..............3......3......3......................#######.....................................................................................................................................",
        ".....S.........3..................3..............###.............#...#...........................#...#..............T......T......T......................#.....#..............................................................V..................3.3.....................................9...........",
        "....###.......###.......E........###.............###.......E.....#...#...................3.......#...#.......................................E...........#.....#...........E..........^...........V...........^.............#####...............#####...................................###..........",
        "####...#######...#######T########...####...######...#######T#####.....#########...#######T#######.....#######...####...####...####...#########T##########.......###########T##########^###########...#########^#############.......###############.....####################################...##########"
    ],
    // LEVEL 3: BOSS ARENA
    [
        "...............................................................................................................................",
        "...............................................................................................................................",
        "...............................................................................................................................",
        "...............................................................................................................................",
        "...............................................................................................................................",
        "...............................................................................................................................",
        "...............................................................................................................................",
        ".......S.....................T.......................................................T.......................9.................",
        ".....#####.......................3...........B...........3.................................................#####...............",
        "####.......#####################################################################################.....######...#################"
    ]
];

let player = { x: 0, y: 0, radius: 9, vx: 0, vy: 0, angle: 0, onGround: false, dead: false, facing: 1 };
let tiles = [];
let water = [];
let coins = [];
let spikes = [];
let enemies = []; 
let goal = null;
let startPos = {x:0, y:0};

function parseLevel(idx) {
    tiles=[]; water=[]; coins=[]; spikes=[]; enemies=[]; decor=[]; goal=null; particles=[]; bullets=[]; enemyBullets=[];
    let map = levels[idx]; if(!map) return;

    for(let r=0; r<map.length; r++) {
        for(let c=0; c<map[r].length; c++) {
            let ch = map[r][c];
            let x = c * TILE_SIZE;
            let y = r * TILE_SIZE + 60; 

            if(ch==='#' || ch==='T') {
                tiles.push({x, y, type: ch}); 
                if(ch === '#' && r > 0 && map[r-1][c] === '.') if(Math.random() > 0.7) decor.push({x: x, y: y-10, type: 'flower'});
            }
            if(ch==='~') water.push({x, y});
            if(ch==='S') { player.x = x+10; player.y = y; startPos = {x:x+10, y:y}; }
            if(ch==='3') coins.push({x: x+10, y: y+10, active: true});
            if(ch==='^') spikes.push({x: x, y: y});
            if(ch==='9') goal = {x: x, y: y};
            if(ch==='E') { enemies.push({type: 'h', x: x+10, y: y+8, vx: 1.0, vy: 0, active: true}); tiles.push({x, y, type: '#'}); }
            if(ch==='V') {
                let minY = y - 60, maxY = y + 20; 
                for(let k=r; k>=0; k--) if(map[k][c] === '#') { minY = (k+1)*TILE_SIZE + 60; break; }
                for(let k=r; k<map.length; k++) if(map[k][c] === '#') { maxY = (k-1)*TILE_SIZE + 60; break; }
                enemies.push({ type: 'v', x: x+10, y: y+8, vx: 0, vy: 1.2, minY: minY, maxY: maxY, active: true });
            }
            // BOSS
            if(ch==='B') {
                enemies.push({
                    type: 'boss', x: x+20, y: y, vx: 0, vy: 0, hp: 15, maxHp: 15, active: true,
                    timer: 0, state: 'idle', facing: -1
                });
            }
        }
    }
}

function spawnParticles(x, y, color, count) {
    for(let i=0; i<count; i++) particles.push({x: x, y: y, vx: (Math.random()-0.5)*5, vy: (Math.random()-0.5)*5, life: 1.0, color: color});
}

function shoot() {
    let now = Date.now(); if (now - lastShootTime < 400) return;
    lastShootTime = now; Sound.play('shoot');
    bullets.push({ x: player.x, y: player.y, vx: 7 * player.facing, life: 70 });
    spawnParticles(player.x + (10*player.facing), player.y, '#ffeb3b', 5);
}

function updatePhysics() {
    if(player.dead) return;
    if (keys.left) { player.vx -= ACCEL; player.facing = -1; }
    if (keys.right) { player.vx += ACCEL; player.facing = 1; }
    player.vx *= FRICTION;
    if(player.vx > MAX_SPEED) player.vx = MAX_SPEED; if(player.vx < -MAX_SPEED) player.vx = -MAX_SPEED;
    player.angle += player.vx * 0.15; player.x += player.vx; checkTileCollision('x', player);
    player.vy += GRAVITY;
    if(keys.up && player.onGround) { player.vy = JUMP_FORCE; player.onGround = false; Sound.play('jump'); spawnParticles(player.x, player.y + 10, '#fff', 3); }
    player.y += player.vy; player.onGround = false; checkTileCollision('y', player);
    if(player.y > 600) killPlayer("Oops! You fell.");
    updateEntities();
}

function checkTileCollision(axis, obj) {
    let r = (obj.radius || 9), t_size = TILE_SIZE;
    let startC = Math.floor((obj.x - r) / t_size), endC = Math.floor((obj.x + r) / t_size);
    let startR = Math.floor((obj.y - r) / t_size), endR = Math.floor((obj.y + r) / t_size);

    for(let t of tiles) {
        if(t.x < (startC-1)*t_size || t.x > (endC+1)*t_size || t.y < (startR-1)*t_size || t.y > (endR+1)*t_size) continue;
        if (obj.x + r > t.x && obj.x - r < t.x + t_size && obj.y + r > t.y && obj.y - r < t.y + t_size) {
            if(axis === 'x') {
                if(obj.vx > 0) obj.x = t.x - r - 0.1;
                if(obj.vx < 0) obj.x = t.x + t_size + r + 0.1;
                obj.vx = 0;
            } else {
                if(obj.vy > 0) { 
                    obj.y = t.y - r - 0.1; 
                    if(obj === player) {
                        obj.onGround = true;
                        if(t.type === 'T') { obj.vy = BOUNCE_FORCE; obj.onGround = false; Sound.play('jump'); spawnParticles(obj.x, obj.y+10, '#ff9800', 8); } 
                        else obj.vy = 0;
                    } else obj.vy = 0; // Enemies don't use trampolines
                } else if (obj.vy < 0) { obj.y = t.y + t_size + r + 0.1; obj.vy = 0; }
            }
        }
    }
}

function updateEntities() {
    let currentMap = levels[currentLevelIndex];

    enemies.forEach(e => {
        if(!e.active) return;
        
        // BOSS LOGIC
        if(e.type === 'boss') {
            e.radius = 18;
            e.timer++;
            // Simple AI: Move towards player, Jump if blocked or random
            if(e.state === 'idle') {
                let dx = player.x - e.x;
                e.vx = dx > 0 ? 1.5 : -1.5;
                if(Math.abs(dx) < 10) e.vx = 0;
                // Ability: Magma Burst
                if(e.timer > 150) { e.state = 'charge'; e.timer = 0; e.vx = 0; }
            } else if (e.state === 'charge') {
                if(e.timer > 40) {
                    e.state = 'idle'; e.timer = 0;
                    Sound.play('boss_shoot');
                    // Shoot 3 bullets
                    enemyBullets.push({x: e.x, y: e.y, vx: -3, vy: -1, life: 100});
                    enemyBullets.push({x: e.x, y: e.y, vx: 3, vy: -1, life: 100});
                    enemyBullets.push({x: e.x, y: e.y, vx: (player.x-e.x)*0.05, vy: -3, life: 100});
                }
            }
            e.vy += GRAVITY;
            e.x += e.vx; checkTileCollision('x', e);
            e.y += e.vy; checkTileCollision('y', e);
        }
        else if(e.type === 'h') {
            let lookAheadX = e.x + (e.vx * 15);
            let mapR = Math.floor((e.y - 60) / TILE_SIZE);
            let mapC = Math.floor(lookAheadX / TILE_SIZE);
            let wallAhead = false, ledgeAhead = true;
            if(mapR >= 0 && mapR < currentMap.length && mapC >= 0 && mapC < currentMap[0].length) {
                let char = currentMap[mapR][mapC];
                if(char === '#' || char === 'T') wallAhead = true;
                let floorChar = (mapR+1 < currentMap.length) ? currentMap[mapR+1][mapC] : '.';
                if(floorChar === '#' || floorChar === 'T') ledgeAhead = false;
            }
            if(wallAhead || ledgeAhead) e.vx *= -1;
            e.x += e.vx; 
        } else if (e.type === 'v') {
            e.y += e.vy; if(e.y < e.minY || e.y > e.maxY) e.vy *= -1;
        }
        
        // Collision with Player
        let dx = player.x - e.x, dy = player.y - e.y;
        let dist = (e.type === 'boss') ? 30 : 20;
        if(dx*dx + dy*dy < dist*dist) { 
            if (player.vy > 0 && player.y < e.y - (e.type==='boss'?15:8)) { 
                player.vy = -6; 
                if(e.type === 'boss') {
                    e.hp--; Sound.play('boss_hit'); spawnParticles(e.x, e.y, '#fff', 5);
                    if(e.hp <= 0) { e.active = false; score += 500; spawnParticles(e.x, e.y, '#ab47bc', 50); }
                } else {
                    e.active = false; score += 50; Sound.play('enemy'); spawnParticles(e.x, e.y, '#ab47bc', 10);
                }
                document.getElementById('scoreVal').innerText = score; 
            } else { killPlayer("Ouch! Enemy!"); }
        }
    });

    coins.forEach(c => {
        if(!c.active) return;
        if((player.x-c.x)**2 + (player.y-c.y)**2 < 250) { c.active = false; score += 10; Sound.play('coin'); document.getElementById('scoreVal').innerText = score; spawnParticles(c.x, c.y, '#FFD700', 5); }
    });

    // Player Bullets
    for(let i=bullets.length-1; i>=0; i--) {
        let b = bullets[i]; b.x += b.vx; b.life--; 
        if(b.life <= 0) { bullets.splice(i, 1); continue; }
        let hit = false;
        for(let e of enemies) {
            if(!e.active) continue;
            let dist = (e.type === 'boss') ? 30 : 15;
            if((b.x-e.x)**2 + (b.y-e.y)**2 < dist*dist) {
                 bullets.splice(i, 1); hit = true; 
                 if(e.type === 'boss') {
                     e.hp--; Sound.play('boss_hit'); spawnParticles(e.x, e.y, '#fff', 3);
                     if(e.hp <= 0) { e.active = false; score += 500; spawnParticles(e.x, e.y, '#ab47bc', 50); }
                 } else {
                     e.active = false; score += 50; Sound.play('enemy'); spawnParticles(e.x, e.y, '#ab47bc', 10);
                 }
                 document.getElementById('scoreVal').innerText = score; break;
            }
        }
        if(hit) continue;
        for(let t of tiles) {
            if(b.x > t.x && b.x < t.x+TILE_SIZE && b.y > t.y && b.y < t.y+TILE_SIZE) { spawnParticles(b.x, b.y, '#fff', 3); bullets.splice(i, 1); break; }
        }
    }

    // Enemy Bullets (Magma)
    for(let i=enemyBullets.length-1; i>=0; i--) {
        let b = enemyBullets[i]; b.x += b.vx; b.y += b.vy; b.life--;
        b.vy += 0.1; // Gravity on magma
        if(b.life <= 0) { enemyBullets.splice(i, 1); continue; }
        if((b.x-player.x)**2 + (b.y-player.y)**2 < 200) killPlayer("Burned by Magma!");
        for(let t of tiles) {
            if(b.x > t.x && b.x < t.x+TILE_SIZE && b.y > t.y && b.y < t.y+TILE_SIZE) { spawnParticles(b.x, b.y, '#ff5722', 3); enemyBullets.splice(i, 1); break; }
        }
    }
    
    for(let i=particles.length-1; i>=0; i--) { let p = particles[i]; p.x += p.vx; p.y += p.vy; p.life -= 0.05; if(p.life <= 0) particles.splice(i, 1); }

    for(let s of spikes) if(Math.abs(player.x - s.x) < 10 && Math.abs(player.y - s.y) < 15) killPlayer("Stepped on spike");
    for(let w of water) if (player.x > w.x && player.x < w.x+20 && player.y > w.y+5) killPlayer("Fall on water");
    if(goal && Math.abs(player.x - goal.x) < 20 && Math.abs(player.y - goal.y) < 30) completeLevel();
}

function killPlayer(reason) {
    if(player.dead) return;
    player.dead = true; player.vx = 0; player.vy = -5; Sound.play('die'); spawnParticles(player.x, player.y, '#ff3333', 15);
    setTimeout(() => { showOverlay("TRY AGAIN!", reason, "RETRY"); }, 800);
}

function completeLevel() {
    gameState = 'WIN_LEVEL'; Sound.play('coin');
    if(currentLevelIndex >= levels.length - 1) {
        showOverlay("VICTORY!", "You defeated the Dark King!<br>Score: " + score, "PLAY AGAIN");
        gameState = 'GAME_COMPLETE';
    } else {
        showOverlay("LEVEL DONE!", "Great Work!", "NEXT LEVEL");
    }
}

function draw() {
    globalTime++;
    let colorTop = currentLevelIndex === 2 ? '#311b92' : (currentLevelIndex === 0 ? '#4fc3f7' : '#ff7043'); 
    let colorBot = currentLevelIndex === 2 ? '#000000' : (currentLevelIndex === 0 ? '#e1f5fe' : '#ffccbc');
    let grad = ctx.createLinearGradient(0, 0, 0, canvas.height); grad.addColorStop(0, colorTop); grad.addColorStop(1, colorBot);
    ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);

    if (gameState === 'MENU') return;

    let targetX = player.x - canvas.width / 2; if(targetX < 0) targetX = 0;
    let mapW = levels[currentLevelIndex][0].length * TILE_SIZE; if(targetX > mapW - canvas.width) targetX = mapW - canvas.width;
    camera.x += (targetX - camera.x) * 0.1;

    ctx.save(); ctx.translate(-camera.x * 0.2, 0); ctx.fillStyle = 'rgba(255,255,255,0.6)';
    for(let i=0; i<30; i++) { let cx = i * 250; let cy = 50 + Math.sin(i)*20; ctx.beginPath(); ctx.arc(cx, cy, 30, 0, Math.PI*2); ctx.arc(cx+40, cy+10, 35, 0, Math.PI*2); ctx.fill(); }
    ctx.restore();

    ctx.save(); ctx.translate(-Math.floor(camera.x), 0); 
    
    tiles.forEach(t => { if(t.x > camera.x - 30 && t.x < camera.x + 500) { if(t.type === 'T') ctx.drawImage(bounceSprite, t.x, t.y); else ctx.drawImage(tileSprite, t.x, t.y); }});
    decor.forEach(d => { if(d.x > camera.x - 30 && d.x < camera.x + 500) ctx.drawImage(flowerSprite, d.x, d.y); });
    ctx.fillStyle = '#444'; spikes.forEach(s => { if(s.x > camera.x - 30 && s.x < camera.x + 500) { ctx.beginPath(); ctx.moveTo(s.x+2, s.y+20); ctx.lineTo(s.x+10, s.y+2); ctx.lineTo(s.x+18, s.y+20); ctx.fill(); } });
    ctx.fillStyle = '#FFEB3B'; for(let b of bullets) { ctx.beginPath(); ctx.arc(b.x, b.y, 5, 0, Math.PI*2); ctx.fill(); }
    
    ctx.fillStyle = '#ff5722'; 
    for(let b of enemyBullets) { ctx.beginPath(); ctx.arc(b.x, b.y, 6, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle='white'; ctx.stroke(); }

    enemies.forEach(e => {
        if(e.active && e.x > camera.x - 30 && e.x < camera.x + 500) {
            ctx.save(); ctx.translate(e.x, e.y);
            if(e.type === 'boss') {
                if(e.state === 'charge') { 
                    ctx.globalCompositeOperation = 'source-atop'; ctx.fillStyle = 'white'; 
                    if(Math.floor(globalTime/4)%2===0) ctx.filter = 'invert(1)';
                }
                ctx.drawImage(bossSprite, -20, -20);
                ctx.filter = 'none';
                // Health Bar
                ctx.fillStyle = 'red'; ctx.fillRect(-20, -35, 40, 5);
                ctx.fillStyle = '#00e676'; ctx.fillRect(-20, -35, 40 * (e.hp/e.maxHp), 5);
            } else if(e.type === 'h') {
                ctx.rotate(Math.sin(globalTime/6)*0.2); ctx.drawImage(enemySprite, -12, -12);
            } else { 
                let flap = Math.sin(globalTime/3)*3; ctx.fillStyle = '#fff'; ctx.beginPath(); ctx.arc(-8, -5+flap, 4, 0, Math.PI*2); ctx.fill(); ctx.beginPath(); ctx.arc(8, -5+flap, 4, 0, Math.PI*2); ctx.fill(); ctx.drawImage(enemySprite, -12, -12);
            }
            ctx.restore();
        }
    });

    if(goal) ctx.drawImage(flagSprite, goal.x, goal.y - 20);

    coins.forEach(c => {
        if(c.active && c.x > camera.x - 30 && c.x < camera.x + 500) {
            let bounce = Math.sin(globalTime / 10) * 3;
            ctx.fillStyle = '#FFD700'; ctx.beginPath(); ctx.arc(c.x, c.y + bounce, 7, 0, Math.PI*2); ctx.fill(); ctx.strokeStyle = '#fff'; ctx.lineWidth = 2; ctx.stroke();
        }
    });

    if(!player.dead) {
        ctx.save(); ctx.translate(player.x, player.y); ctx.rotate(player.angle);
        ctx.drawImage(ballSprite, -player.radius, -player.radius, player.radius*2, player.radius*2);
        ctx.restore();
    }

    let wave = Math.sin(globalTime/15) * 2;
    water.forEach(w => { if(w.x > camera.x - 30 && w.x < camera.x + 500) ctx.drawImage(waterSprite, w.x, w.y + wave); });
    particles.forEach(p => { ctx.fillStyle = p.color; ctx.globalAlpha = p.life; ctx.fillRect(p.x, p.y, 4, 4); ctx.globalAlpha = 1.0; });
    ctx.restore();
}

function gameLoop() { if(gameState === 'PLAY') updatePhysics(); draw(); requestAnimationFrame(gameLoop); }

function showOverlay(title, msg, btnText) {
    gameState = (gameState === 'GAME_COMPLETE' ? 'GAME_COMPLETE' : 'MENU');
    document.getElementById('overlay-title').innerHTML = title; document.getElementById('overlay-msg').innerHTML = msg; document.getElementById('overlay-btn').innerText = btnText; document.getElementById('overlay').style.display = 'flex';
}
function handleOverlayClick() {
    Sound.init(); const btnText = document.getElementById('overlay-btn').innerText; document.getElementById('overlay').style.display = 'none';
    if(btnText === 'LET\'S GO!' || btnText === 'PLAY AGAIN') { currentLevelIndex = 0; score = 0; document.getElementById('scoreVal').innerText = '0'; resetLevel(); } 
    else if (btnText === 'RETRY') { resetLevel(); } else if (btnText === 'NEXT LEVEL') { currentLevelIndex++; resetLevel(); }
}
function resetLevel() {
    parseLevel(currentLevelIndex);
    player.x = startPos.x; player.y = startPos.y; player.vx = 0; player.vy = 0; player.angle = 0; player.dead = false; player.onGround = false; player.facing = 1;
    document.getElementById('levelDisplay').innerText = "LEVEL " + (currentLevelIndex + 1); gameState = 'PLAY';
}

window.addEventListener('keydown', e => { if(e.code === 'ArrowLeft') keys.left = true; if(e.code === 'ArrowRight') keys.right = true; if(e.code === 'ArrowUp' || e.code === 'Space') keys.up = true; if(e.code === 'KeyZ') shoot(); });
window.addEventListener('keyup', e => { if(e.code === 'ArrowLeft') keys.left = false; if(e.code === 'ArrowRight') keys.right = false; if(e.code === 'ArrowUp' || e.code === 'Space') keys.up = false; });
const addTouch = (id, k) => { const el = document.getElementById(id); el.addEventListener('touchstart', (e) => { e.preventDefault(); keys[k] = true; }); el.addEventListener('touchend', (e) => { e.preventDefault(); keys[k] = false; }); };
addTouch('btn-left', 'left'); addTouch('btn-right', 'right'); addTouch('btn-jump', 'up');
document.getElementById('btn-shoot').addEventListener('touchstart', (e) => { e.preventDefault(); shoot(); });

gameState = 'MENU'; gameLoop();

</script>
</body>
</html>